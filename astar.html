<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>A* Visualization</title>
    <!-- Load p5.js and p5.sound.js -->
    <script src="./libraries/js/p5.min.js"></script>
    <script src="./libraries/js/p5.sound.min.js"></script>
    <link rel="stylesheet" href="./libraries/css/bootstrap.min.css" />
    <link rel="stylesheet" href="./app/css/style.css" />
  </head>
  <body>
    <div class="d-flex flex-row justify-content-between">
      <div>
        Choose Wall Percentage: <span id="wallPercentageValue">25%</span>
        <input
          title="wallSlider"
          type="range"
          id="wallSlider"
          min="0"
          max="100"
          value="25"
          step="1"
        />
      </div>
      <button id="initializeButton">Generate new Grid</button>
      <!-- Button to reinitialize the grid -->
    </div>

    <script>
      // Helper function to remove an item from an array
      function removeFromArray(arr, item) {
        const index = arr.indexOf(item);
        if (index > -1) {
          arr.splice(index, 1);
        }
      }

      let cols = 30;
      let rows = 30;
      let grid = new Array(cols);
      let openSet = [];
      let closedSet = [];
      let start;
      let end;
      let w, h;
      let path = [];
      let endSelected = false;
      let gridInitialized = false; // Flag to track grid initialization
      let wallPercentage = 0.25;

      // Listen for messages from parent window
      window.addEventListener("message", function (event) {
        const data = event.data;
        if (data.action === "updateWallPercentage") {
          wallPercentage = data.value; // Update wall percentage
          resetGrid(); // Reset the grid with the new wall percentage
        } else if (data.action === "updateGridSize") {
          cols = data.cols; // Update columns
          rows = data.rows; // Update rows
          resetGrid(); // Reset the grid with the new size
        }
      });

      // Spot constructor
      function Spot(i, j) {
        this.i = i;
        this.j = j;
        this.f = 0;
        this.g = 0;
        this.h = 0;
        this.neighbors = [];
        this.previous = undefined;
        this.wall = false;

        if (random(1) < wallPercentage) {
          this.wall = true;
        }

        this.show = function (col) {
          fill(col);
          if (this.wall) {
            fill(0);
          }
          noStroke();
          rect(this.i * w, this.j * h, w - 1, h - 1);
        };

        this.addNeighbors = function (grid) {
          let i = this.i;
          let j = this.j;
          if (i < cols - 1) this.neighbors.push(grid[i + 1][j]);
          if (i > 0) this.neighbors.push(grid[i - 1][j]);
          if (j < rows - 1) this.neighbors.push(grid[i][j + 1]);
          if (j > 0) this.neighbors.push(grid[i][j - 1]);
          if (i > 0 && j > 0) this.neighbors.push(grid[i - 1][j - 1]);
          if (i < cols - 1 && j > 0) this.neighbors.push(grid[i + 1][j - 1]);
          if (i > 0 && j < rows - 1) this.neighbors.push(grid[i - 1][j + 1]);
          if (i < cols - 1 && j < rows - 1)
            this.neighbors.push(grid[i + 1][j + 1]);
        };
      }

      // Setup the canvas and grid
      function setup() {
        createCanvas(650, 650);
        frameRate(5);

        // Recalculate cell width and height when the grid changes
        w = width / cols;
        h = height / rows;

        // Initialize grid
        resetGrid();

        // Add event listener for wall slider after p5.js setup
        document
          .getElementById("wallSlider")
          .addEventListener("input", function () {
            wallPercentage = this.value / 100; // Convert slider value to percentage
            document.getElementById(
              "wallPercentageValue"
            ).innerText = `${this.value}%`; // Update displayed value
            resetGrid(); // Reinitialize grid with new wall percentage
          });

        // Event listener for initializing the grid
        document
          .getElementById("initializeButton")
          .addEventListener("click", resetGrid);
      }

      // Reset grid with the new wall percentage and grid size
      function resetGrid() {
        grid = new Array(cols);
        for (let i = 0; i < cols; i++) {
          grid[i] = new Array(rows);
        }

        // Recalculate cell width and height
        w = width / cols;
        h = height / rows;

        for (let i = 0; i < cols; i++) {
          for (let j = 0; j < rows; j++) {
            grid[i][j] = new Spot(i, j);
          }
        }

        for (let i = 0; i < cols; i++) {
          for (let j = 0; j < rows; j++) {
            grid[i][j].addNeighbors(grid);
          }
        }

        start = grid[0][0];
        end = grid[cols - 1][rows - 1];
        start.wall = false;
        end.wall = false;

        openSet = [start];
        closedSet = [];
        path = [];

        gridInitialized = true; // Mark the grid as initialized
        endSelected = false; // Ensure end point is not selected after reset

        loop(); // Restart the A* algorithm when grid is reset
      }

      // Heuristic function for A* algorithm
      function heuristic(a, b) {
        let d = abs(a.i - b.i) + abs(a.j - b.j);
        return d;
      }

      // Draw function for A* visualization
      function draw() {
        background(0);

        // Draw the grid
        for (let i = 0; i < cols; i++) {
          for (let j = 0; j < rows; j++) {
            grid[i][j].show(color(255));
          }
        }

        if (end) {
          end.show(color(0, 255, 255)); // Cyan for the end point
        }

        // If the end point is not selected, stop the algorithm
        if (!endSelected) {
          fill(255, 255, 0);

          return; // Stop execution until the end point is selected
        }

        // A* algorithm starts here if the end point is selected and grid is initialized
        if (gridInitialized && openSet.length > 0) {
          let winner = 0;
          for (let i = 0; i < openSet.length; i++) {
            if (openSet[i].f < openSet[winner].f) {
              winner = i;
            }
          }

          var current = openSet[winner];

          if (current === end) {
            noLoop();
            console.log("Done!");
          }

          removeFromArray(openSet, current);
          closedSet.push(current);

          let neighbors = current.neighbors;
          for (let i = 0; i < neighbors.length; i++) {
            let neighbor = neighbors[i];

            if (!closedSet.includes(neighbor) && !neighbor.wall) {
              let tempG = current.g + 1;

              let newPath = false;
              if (openSet.includes(neighbor)) {
                if (tempG < neighbor.g) {
                  neighbor.g = tempG;
                  newPath = true;
                }
              } else {
                neighbor.g = tempG;
                newPath = true;
                openSet.push(neighbor);
              }

              if (newPath) {
                neighbor.h = heuristic(neighbor, end);
                neighbor.f = neighbor.g + neighbor.h;
                neighbor.previous = current;
              }
            }
          }
        } else {
          console.log("No solution");
          noLoop();
          return;
        }

        // Show visited and path points
        for (let i = 0; i < closedSet.length; i++) {
          closedSet[i].show(color(255, 0, 0));
        }

        for (let i = 0; i < openSet.length; i++) {
          openSet[i].show(color(0, 255, 0));
        }

        path = [];
        let temp = current;
        path.push(temp);
        while (temp.previous) {
          path.push(temp.previous);
          temp = temp.previous;
        }

        for (let i = 0; i < path.length; i++) {
          path[i].show(color(0, 0, 255));
        }
      }

      // Mouse pressed function to set end point
      function mousePressed() {
        let i = floor(mouseX / w);
        let j = floor(mouseY / h);

        if (i >= 0 && i < cols && j >= 0 && j < rows) {
          let clickedSpot = grid[i][j];

          if (!clickedSpot.wall) {
            end = clickedSpot;
            endSelected = true;
            openSet = [];
            closedSet = [];
            path = [];
            openSet.push(start);
            loop();
          }
        }
      }

      // Initialize grid when page loads
      window.onload = resetGrid;
    </script>
  </body>
</html>
